void	ft_pos_new_line(t_data *data)
{
	int len;
	int *pos;
	int count;
	t_list *tmp;
	t_list *tmp_;

	// count = 0;
	// tmp = NULL;
	// tmp_ = NULL;
	// pos = ft_memalloc(2);
	// len = (int)data->sel->len_prompt + (int)data->entry->len_line;
	// if (data->sel->pos[1] < len - 1)
	// {
	// 	pos[1] = data->sel->pos[1];
	// 	pos[0] = data->sel->pos[0];
	// 	tmp = ft_find_pos_int_lst(data);
	// 	tmp_ = tmp;
	// 	ft_move_cursor(data, RIGHT);
	// 	while (tmp)
	// 	{
	// 		ft_move_cursor(data, RIGHT);
	// 		del_one_character(data, DEL);
	// 		tmp = tmp->next;
	// 	}
	// 	print_lst_line(data, tmp_->next);
	// 	tputs(tgoto(tgetstr("cm", NULL), pos[1] + 1, pos[0]), 1, ft_putchar_select);
	// 	// if (len > (data->term->width - 1) && pos < len)
	// 	// {
	// 	// 	tmp = data->entry->line;
			
	// 	// 	//ft_putnbr_fd(data->entry->len_line/data->term->width, data->term->tty);
	// 	// 	//print_lst_line(data, tmp);
	// 	// 	tmp = NULL;
	// 	// }
	// }
	if (data->sel->pos[1] == (data->term->width - 1) && data->sel->pos[0] == (data->term->height - 1))
	{
		ft_putchar_fd('\n', data->term->tty);
		data->sel->pos_start[0] -= 1;
	}
}

t_list	*ft_find_pos_int_lst(t_data *data)
{
	int count;
	int multipy;
	t_list *tmp;

	count = -1;
	tmp = NULL;
	tmp = data->entry->line;
	data->sel->pos_search = 0;
	if (data->sel->pos[0] == data->sel->pos_start[0])
		data->sel->pos_search = (data->sel->pos[1] - data->sel->len_prompt);
	else
	{
		multipy = 0;
		multipy = (data->entry->len_line - data->sel->len_prompt);
		// data->sel->pos_search = data->sel->pos[1] - data->sel->len_prompt;
		data->sel->pos_search = (data->entry->len_line - data->sel->len_prompt) - (data->sel->pos[1]);
	}
	while(tmp->next && ++count <= data->sel->pos_search)
		tmp = tmp->next;
	return (tmp);
}

void ft_move_left(t_data *data)
{
	t_select *sel;

	sel = NULL;
	sel = data->sel;
	if (sel->pos[1] > (int)sel->len_prompt && sel->pos[0] == sel->pos_start[0])
		data->sel->pos[1] -= 1;
	else if (sel->pos[0] != sel->pos_start[0] && sel->pos[1] > 0)
		data->sel->pos[1] -= 1;
	else if (sel->pos[1] == 0)
	{
		data->sel->pos[1] = (data->term->width - 1);
		data->sel->pos[0] -= 1;
	}
	else
		return ;
}


t_cmd		*data_check_str_list_struct_cmd(t_data *data, char *line_str)
{
	t_cmd	*cmd_node;
	char 	*caract;
	char 	**tmp;
	//int 	i;

	tmp = NULL;
	// i = 0;
	caract = NULL;
	cmd_node = NULL;
	ft_putstr_fd("\n", data->term->tty);
	ft_putstr_fd(line_str, data->term->tty);
	ft_putstr_fd("\nif\n", data->term->tty);
	if (data_check_special_caract_global(data, line_str, &caract) && line_str)
	{
		ft_putstr_fd("K\n", data->term->tty);
		//ft_putstr_fd(caract, data->term->tty);
		tmp = data_split_to_tab(line_str, caract);
		// while(tmp[i])
		// {
		// 	ft_putstr_fd("-", data->term->tty);
		// 	ft_putstr_fd(tmp[i], data->term->tty);
		// 	ft_putstr_fd("\n", data->term->tty);
		// 	i++;
		// }
		// ft_putnbr_fd(i, data->term->tty);
		while (tmp)
		{
			
			if (tmp)
				// ft_putstr_fd(tmp[i], data->term->tty);
				// ft_putstr_fd("|", data->term->tty);
				// ft_putstr_fd(tmp[i + 2], data->term->tty);
				// ft_putstr_fd("\n", data->term->tty);
				return (data_check_str_list_struct_cmd(data, (*tmp)));
			tmp++;
		}
	}
	else
		return (data_create_list_struct_cmd(data, line_str));
}

// static t_parse	*data_parsing_init(void)
// {
// 	static	t_lex	p[] = {
// 		{"|", data_parse_pipe},
// 		{"<", data_ope_left},
// 		{">", data_ope_right},
// 		{"<<", data_ope_double_left},
// 		{">>", data_ope_double_right},
// 		{"&&", data_ope_and},
// 		{";", data_ope_semicolon},
// 		{NULL, NULL}
// 	};
// 	return ((void *)p);
// }

// int				data_parsing_drive(t_data *data)
// {
// 	int		i;
// 	t_lex	*parse;

// 	i = 0;
// 	parse = NULL;
// 	parse = data_parsing_init();
// 	while (parse[i].c)
// 	{
// 		if (parse[i])
// 			return (parse[i].f(data));
// 		i++;
// 	}
// 	return (0);
// }

// int 		data_check_special_caract_inside(char str)
// {
// 	if (str == "<")
// 		return (1);
// 	if (str == ">")
// 		return (1);
// 	if (str == "|")
// 		return (1);
// 	if (str == ";")
// 	return (1);
// }

// int			ft_striter_data_c(char *s, void (*f)(char *))
// {
// 	if (s && f)
// 	{
// 		while (*s)
// 			return(f(s++));
// 	}
// 	return (0);
// }

// int 		data_check_special_caract(t_data *data, char *str)
// {
// 	int i;

// 	i = 0;
// 	if (ft_strcmp(str, "|"))
// 		return (1);
// 	if (ft_strcmp(str, "&&"))
// 		return (1);
// 	ft_striter_data_c(str, &data_check_special_caract_inside);
// 	return (0);
// }

**********************************************

t_cmd		*data_check_str_list_struct_cmd(t_data *data, char *line_str, size_t nbr)
{
	t_cmd	*cmd_node;
	char 	*caract;
	char 	**tmp;

	tmp = NULL;
	caract = NULL;
	cmd_node = NULL;
	ft_putstr_fd("\n", data->term->tty);
	ft_putstr_fd(line_str, data->term->tty);
	ft_putstr_fd("\nif\n", data->term->tty);
	if (data_check_special_caract_global(data, line_str, &caract) && line_str)
	{
		tmp = data_split_to_tab(line_str, caract);
		nbr = ft_count_tab(tmp);
	}
	if (nbr > 1)
	{
		return (data_check_str_list_struct_cmd(data, tmp[nbr], nbr - 1));
	}
	return(data_create_list_struct_cmd(data, line_str));
}

**********************************************

int 		data_check_special_caract_global(t_data *data, char *line_str, char **caract)
{
	int i;

	i = 0;
	(void)data;
	while (line_str[i])
	{
		if (line_str[i + 1])
		{

			if (line_str[i] == '<' && line_str[i + 1] != '<' && line_str[i + 1])
			{
				(*caract) = ft_strdup("<");
				return (1);
			}
			else if (line_str[i] == '>' && line_str[i + 1] != '>' && line_str[i + 1])
			{
				(*caract) = ft_strdup(">");
				return (1);
			}
			else if (line_str[i] == '|' && line_str[i + 1] != '|' && line_str[i + 1])
			{
				(*caract) = ft_strdup("|");
				return (1);
			}
			else if (line_str[i] == ';' && line_str[i + 1] != '|' && line_str[i + 1])
			{
				(*caract) = ft_strdup(";");
				return (1);
			}
		}
		else
			break ;
		i++;
	}
	return (0);
}


// {
	
// 	char 	**tmp;
// 	int		type;
// 	void	*node;
// 	int 	i;

// 	type = 0;
// 	i = 0;
// 	node = NULL;
// 	tmp = NULL;
// 	tmp = data_clean_to_tab(data, line_str);
// 	ft_free_char(tmp);
// 	return ;
// }

// {
// 	char 	**tmp;
// 	char 	*caract;
// 	int		type;
// 	void	*node;

// 	tmp = NULL;
// 	if (i == size)
// 		return ;
// 	if (i < size)
// 	{
// 		if (data_check_special_caract_global(data, line_str[i], &caract) && line_str[i])
// 		{
// 			tmp = data_split_to_tab(line_str[i], caract);
// 			size = ft_count_tab(tmp);
// 			return (data_check_str_list_struct_cmd_loop(data, tmp, 0, size));
// 		}
// 	}
// 	data_create_list_struct(data, line_str, &node, &type);
// 	ft_lstadd_back(&data->cmd, data_check_str_list_struct_node(data, node, type));
// 	return ;
// }